<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <title>Nonempty Intervals and Generalized Arrays</title><link rel="stylesheet" href="http://srfi.schemers.org/srfi.css">
  </head>
  <body>
    <h1>Title</h1>
    <p>Nonempty Intervals and Generalized Arrays</p>
    <h1>Author</h1>
    <p>Bradley J. Lucier</p>
    <h1>Status</h1>
    <p>This SRFI is currently in <em>draft</em> status.  Here is <a href="http://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi minus 122 at srfi dot schemers dot org">srfi-122@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="http://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="http://srfi-email.schemers.org/srfi-122">archive</a>.</p>
    <ul>
      <li>Received: 2015/7/23</li>
      <li>Draft #1 published: 2015/7/27</li>
      <li>Draft #2 published: 2015/7/31</li>
      <li>Draft #3 published: 2015/7/31</li>
      <li>Draft #4 published: 2015/9/03</li>
      <li>Draft #4 published: 2015/9/19</li></ul>
    <h1>Abstract</h1>
    <p>This SRFI specifies an array mechanism for Scheme. Arrays as defined here are quite general, and benefit from a data type
       called <i>intervals</i>, which encapsulate the cross product of non-empty intervals of exact integers. These intervals  specify the domain
      information for arrays. An array is then characterized as a mapping from multi-indices of exact integers (i<sub>0</sub>,...,i<sub>d-1</sub>)
      contained in an interval to Scheme values. Additionally, specialized variants of arrays are specified to provide portable programs with efficient representations for common use cases.</p>
    <h1>Rationale</h1>
    <p>An array, as commonly understood, provides a mapping from multi-indices  (i<sub>0</sub>,...,i<sub>d-1</sub>) of exact integers 
      in a non-empty, rectangular, d-dimensional interval
      [l<sub>0</sub>, u<sub>0</sub>) x [l<sub>1</sub>, u<sub>1</sub>) x ... x [l<sub>d-1</sub>, u<sub>d-1</sub>) to Scheme objects.
      Thus, two things are necessary to specify an array: an interval and a mapping.</p>
    <p>Since these two things are often sufficient for certain algorithms, we introduce in this SRFI a minimal set of interfaces for dealing with such arrays.</p>
    <p>Specifically, an array specifies a nonempty, multi-dimensional interval, called its <i>domain</i>, and a mapping from this domain to (single) Scheme objects.  This mapping is called the <i>getter</i> of the array.</p>
    <p>If this mapping can be changed, the array is said to be <i>mutable</i> and the mutation is effected
      by the array's <i>setter</i>.  We call an object of this type a mutable-array.</p>
    <p>In general, we leave the implementation of arrays completely open.  They may be defined simply by closures, or
      they may have hash tables or databases behind an implementation.  If the getter and setter functions of a mutable-array are
      defined by accessing and setting elements  of a one-dimensional (heterogeneous or homogeneous) vector that are determined by a one-to-one function from
      the domain of the array into the integers between 0 (inclusive) and the length of the backing-store vector (exclusive),
      the array is said to be <i>fixed</i>. A specialized-array is an example of a mutable-array.</p>
    <p>Thus,  we  need the concept of an <i>indexer</i>, which is a one-to-one mapping whose domain is an interval and whose range is
      contained in another interval.  Conceptually, an indexer is itself an array that returns multiple values.  An
      important subset of indexers are affine mappings (linear mappings plus constants) from one domain to another.  We do not
      encapsulate indexers, with their domain interval, range interval, and multi-valued mapping, into a distinct type.
      While we considered the formalized use of non-affine indexers in specialized-arrays, we restrict indexers in specialized-arrays to be affine.
      Thus our specialized-arrays are very similar to <a href="#bawden">Bawden-style arrays</a>. (If you want to specify a non-affine indexer into a body, it can be done by constructing a mutable-array.)</p>
    <p>The backing store of a specialized-array, which may be a heterogeneous or homogeneous vector,
      is created, accessed, etc., via the components of an object we call a storage-class.  We define their properties below.</p>
    <p>The API of this SRFI uses keywords from SRFI-88 and the calling convention from SRFI-89 for optional and keyword arguments (although the implementation defines functions with keyword and optional arguments using DSSSL's notation, not the notation from SRFI-89).</p>
    <h1>Examples of application areas</h1>
    <ul>
      <li>Many multi-dimensional transforms in signal processing are <i>separable</i>, in that that the multi-dimensional transform can be computed by applying one-dimensional transforms in each of the coordinate directions.  Examples of such transforms include the Fast Fourier Transform and the Fast Wavelet Transform.  Each one-dimensional subdomain of the complete domain is called a <i>pencil</i>, and the same one-dimensional transform is applied to all pencils in a given direction. This motivates us to define the various procedures *-distinguish-one-axis.</li>
      <li>Many applications have multi-dimensional data that behave differently in different coordinate directions.  For example, one might have a time series of maps, which can be stored in a single three-dimensional array.  Or one might have one-dimensional spectral data assigned to each pixel on a map.  The data cube as a whole is considered three-dimensional <i>hyperspectral</i> data, but for processing the spectra separately one would apply a function to the spectrum at each pixel.  This corresponds to <i>currying</i> arguments in programming languages, so we include such procedures here.</li>
      <li>By default, an array computes each array element each time it is needed.  So the following code
        <pre>
(define (vector-field-sequence-ell-infty-ell-1-ell-2-norm p)
  (array-max (array-map (lambda (p^k)
                          (array-average (array-map Point-length-R^4
                                                    (array-extract p^k
								   (array-domain zero-image)))))
                        p)))</pre>(with suitable definitions for <code>array-max</code>, <code>array-average</code>, and <code>Point-length-R^4</code>) computes the maximum over a number of two-dimensional arrays of the average length of four-vectors in those arrays restricted to the domain of <code>zero-image</code>, without storing all of the elements of any of the intermediate arrays together.</li></ul>
    <h1>Issues and Notes</h1>
    <ul>
      <li><b>Relationship to <a href="http://docs.racket-lang.org/math/array_nonstrict.html#%28tech._nonstrict%29">nonstrict arrays</a> in Racket. </b>It appears that what we call simply arrays in this SRFI are called nonstrict arrays in the math/array library of Racket, which in turn was influenced by an <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/RArrays.pdf">array proposal for Haskell</a>.  Our &quot;specialized&quot; arrays are related to Racket's &quot;strict&quot; arrays.</li>
      <li><b>Indexers. </b>Both the arguments new-domain-&gt;old-domain to <code>specialized-array-share!</code> and indexer to <code>specialized-array</code> are conceptual arrays, 
        the first multiple-valued and the second single-valued.</li>
      <li><b>Source of function names. </b>The function <code>array-curry</code> gets its name from the 
        <a href="http://en.wikipedia.org/wiki/Currying">curry operator</a> in programming---we are currying the getter of the array and keeping careful track of the domains. 
        interval-curry is simply given a parallel name (although it can be thought of as currying the 
        characteristic function of the interval,  encapsulated here as <code>interval-contains-multi-index?</code>).  Similarly, 
        <code>array-distinguish-one-axis</code> makes sense for arrays, but the parallel function for intervals is not very natural.</li>
      <li><b>Choice of functions on intervals. </b>The choice of functions for both arrays and intervals was motivated almost solely by what I needed for arrays.  There are 
        natural operations on intervals, like 
        <blockquote><code>(interval-cross-product interval1 interval2 ...)</code>
        </blockquote>(the inverse of <code>interval-curry</code>) and
        <blockquote><code>(interval-intersect interval1 interval2 ...)</code>
        </blockquote> which don't seem terribly natural for arrays.  If you could use these functions in your programs, tell me (windowing systems, etc.?).</li>
      <li><b>No empty intervals. </b>This SRFI considers arrays over only nonempty intervals of positive dimension.  The author of this proposal acknowledges that other languages and array systems allow either zero-dimensional intervals or empty intervals of positive dimension, but prefers to leave such empty intervals as possibly compatible extensions to the current proposal.</li></ul>
    <h1>Specification</h1>
    <dl>
      <dt>Intervals</dt>
      <dd><a href="#interval">interval</a>,
        <a href="#interval?">interval?</a>,
        <a href="#interval-dimension">interval-dimension</a>,
        <a href="#interval-lower-bound">interval-lower-bound</a>,
        <a href="#interval-upper-bound">interval-upper-bound</a>,
        <a href="#interval-lower-bounds-&gt;list">interval-lower-bounds-&gt;list</a>,
        <a href="#interval-upper-bounds-&gt;list">interval-upper-bounds-&gt;list</a>,
        <a href="#interval-lower-bounds-&gt;vector">interval-lower-bounds-&gt;vector</a>,
        <a href="#interval-upper-bounds-&gt;vector">interval-upper-bounds-&gt;vector</a>,
        <a href="#interval=">interval=</a>,
        <a href="#interval-volume">interval-volume</a>,
        <a href="#interval-subset?">interval-subset?</a>,
        <a href="#interval-contains-multi-index?">interval-contains-multi-index?</a>,
        <a href="#interval-curry">interval-curry</a>,
        <a href="#interval-distinguish-one-axis">interval-distinguish-one-axis</a>,
        <a href="#interval-for-each">interval-for-each</a>,
        <a href="#interval-for-each-serial">interval-for-each-serial</a>,
        <a href="#interval-reduce">interval-reduce</a>,
        <a href="#interval-reduce-serial">interval-reduce-serial</a>,
        <a href="#interval-dilate">interval-dilate</a>.</dd>
      <dt>Arrays</dt>
      <dd><a href="#array">array</a>,
        <a href="#array?">array?</a>,
        <a href="#array-domain">array-domain</a>,
        <a href="#array-getter">array-getter</a>,
        <a href="#array-setter">array-setter</a>,
        <a href="#array-body">array-body</a>,
        <a href="#array-indexer">array-indexer</a>,
        <a href="#array-storage-class ">array-storage-class</a>,
        <a href="#array-map">array-map</a>,
        <a href="#array-curry">array-curry</a>,
        <a href="#array-distinguish-one-axis">array-distinguish-one-axis</a>,
        <a href="#array-for-each">array-for-each</a>,
        <a href="#array-for-each-serial">array-for-each-serial</a>,
        <a href="#array-reduce">array-reduce</a>,
        <a href="#array-reduce-serial">array-reduce-serial</a>.</dd>
      <dt>Mutable Arrays</dt>
      <dd><a href="#mutable-array">mutable-array</a>,
        <a href="#mutable-array?">mutable-array?</a>,
        <a href="#mutable-array-curry">mutable-array-curry</a>,
        <a href="#mutable-array-distinguish-one-axis">mutable-array-distinguish-one-axis</a>.</dd>
      <dt>Storage</dt>
      <dd><a href="#make-storage-class">make-storage-class</a>,
        <a href="#storage-class-getter">storage-class-getter</a>,
        <a href="#storage-class-setter">storage-class-setter</a>,
        <a href="#storage-class-maker">storage-class-maker</a>,
        <a href="#storage-class-length">storage-class-length</a>,
        <a href="#storage-class-default">storage-class-default</a>,
        <a href="#generic-storage-class">generic-storage-class</a>,
        <a href="#s8-storage-class">s8-storage-class</a>,
        <a href="#s16-storage-class">s16-storage-class</a>,
        <a href="#s32-storage-class">s32-storage-class</a>,
        <a href="#s64-storage-class">s64-storage-class</a>,
        <a href="#u1-storage-class">u1-storage-class</a>,
        <a href="#u8-storage-class">u8-storage-class</a>,
        <a href="#u16-storage-class">u16-storage-class</a>,
        <a href="#u32-storage-class">u32-storage-class</a>,
        <a href="#u64-storage-class">u64-storage-class</a>,
        <a href="#f32-storage-class">f32-storage-class</a>,
        <a href="#f64-storage-class">f64-storage-class</a>,
        <a href="#c64-storage-class">c64-storage-class</a>,
        <a href="#c128-storage-class">c128-storage-class</a>.</dd>
      <dt>Indexers</dt>
      <dd><a href="#indexer=">indexer=</a>.</dd>
      <dt>Specialized Arrays</dt>
      <dd><a href="#specialized-array-default-safe?">specialized-array-default-safe?</a>,
        <a href="#specialized-array">specialized-array</a>,
        <a href="#specialized-array?">specialized-array?</a>,
        <a href="#specialized-array-curry">specialized-array-curry</a>,
        <a href="#specialized-array-distinguish-one-axis">specialized-array-distinguish-one-axis</a>,
        <a href="#array-&gt;specialized-array">array-&gt;specialized-array</a>,
        <a href="#array-&gt;specialized-array-serial">array-&gt;specialized-array-serial</a>,
        <a href="#specialized-array-share!">specialized-array-share!</a>.</dd></dl>
    <h2>Intervals</h2>
    <p>Intervals are sets of all multi-indices
      (i<sub>0</sub>,...,i<sub>d-1</sub>)
      such that
      l<sub>0</sub>&lt;=i<sub>0</sub>&lt;u<sub>0</sub>, ..., l<sub>d-1</sub>&lt;=i<sub>d-1</sub>&lt;u<sub>d-1</sub>,
      where the <i>lower bounds</i>
      (l<sub>0</sub>,...,l<sub>d-1</sub>)
      and the <i>upper bounds</i>
      (u<sub>0</sub>,...,u<sub>d-1</sub>)
      are specified as multi-indices of exact integers.  The positive integer d is the <i>dimension</i>
      of the interval.  It is required that
      l<sub>0</sub>&lt;u<sub>0</sub>, ..., l<sub>d-1</sub>&lt;u<sub>d-1</sub>.</p>
    <h3>Procedures</h3>
    <p><b>Procedure: </b><code><a name="interval">interval</a> <var>lower-bounds</var> <var>upper-bounds</var></code></p>
    <p>Create a new interval; <code><var>lower-bounds</var></code> and <code><var>upper-bounds</var></code>
      are nonempty vectors (of the same length) of exact integers that satisfy</p>
    <blockquote><code> (&lt; (vector-ref <var>lower-bounds</var> i) (vector-ref <var>upper-bounds</var> i))</code>
    </blockquote>
    <p> for
      0&lt;=<code>i</code>&lt;<code>(vector-length <var>lower-bounds</var>)</code>.  It is an error if 
      <code><var>lower-bounds</var></code> and <code><var>upper-bounds</var></code> do not satisfy these conditions.</p>
    <p><b>Procedure: </b><code><a name="interval?">interval?</a> <var>obj</var></code></p>
    <p>Returns <code>#t</code> if <code><var>obj</var></code> is an interval, and <code>#f</code> otherwise.</p>
    <p><b>Procedure: </b><code><a name="interval-dimension">interval-dimension</a> <var>interval</var></code></p>
    <p>If <code><var>interval</var></code> is an interval built with </p>
    <blockquote><code>(interval <var>lower-bounds</var> <var>upper-bounds</var>)</code>
    </blockquote>
    <p>then <code>interval-dimension</code> returns <code>(vector-length <var>lower-bounds</var>)</code>.  It is an error to call <code>interval-dimension</code>
      if <code><var>interval</var></code> is not an interval.</p>
    <p><b>Procedure: </b><code><a name="interval-lower-bound">interval-lower-bound</a> <var>interval</var> <var>i</var></code></p>
    <p><b>Procedure: </b><code><a name="interval-upper-bound">interval-upper-bound</a> <var>interval</var> <var>i</var></code></p>
    <p>If <code><var>interval</var></code> is an interval built with </p>
    <blockquote><code>(interval <var>lower-bounds</var> <var>upper-bounds</var>)</code>
    </blockquote>
    <p>and <code><var>i</var></code> is an exact integer that satisfies</p>
    <blockquote>0 &lt;= <code><var>i</var></code> &lt; <code>(vector-length <var>lower-bounds</var>)</code>,
    </blockquote>
    <p> then <code>interval-lower-bound</code> returns
      <code>(vector-ref <var>lower-bounds</var> <var>i</var>)</code> and <code>interval-upper-bound</code> returns
      <code>(vector-ref <var>upper-bounds</var> <var>i</var>)</code>.  It is an error to call <code>interval-lower-bound</code> or <code>interval-upper-bound</code>
      if <code><var>interval</var></code> and <code><var>i</var></code> do not satisfy these conditions.</p>
    <p><b>Procedure: </b><code><a name="interval-lower-bounds-&gt;list">interval-lower-bounds-&gt;list</a> <var>interval</var></code></p>
    <p><b>Procedure: </b><code><a name="interval-upper-bounds-&gt;list">interval-upper-bounds-&gt;list</a> <var>interval</var></code></p>
    <p>If <code><var>interval</var></code> is an interval built with </p>
    <blockquote><code>(interval <var>lower-bounds</var> <var>upper-bounds</var>)</code>
    </blockquote>
    <p> then <code>interval-lower-bounds-&gt;list</code> returns <code>(vector-&gt;list <var>lower-bounds</var>)</code> and  <code>interval-upper-bounds-&gt;list</code> returns <code>(vector-&gt;list <var>upper-bounds</var>)</code>. It is an error to call
      <code>interval-lower-bounds-&gt;list</code> or <code>interval-upper-bounds-&gt;list</code> if <code><var>interval</var></code> does not satisfy these conditions.</p>
    <p><b>Procedure: </b><code><a name="interval-lower-bounds-&gt;vector">interval-lower-bounds-&gt;vector</a> <var>interval</var></code></p>
    <p><b>Procedure: </b><code><a name="interval-upper-bounds-&gt;vector">interval-upper-bounds-&gt;vector</a> <var>interval</var></code></p>
    <p>If <code><var>interval</var></code> is an interval built with </p>
    <blockquote><code>(interval <var>lower-bounds</var> <var>upper-bounds</var>)</code>
    </blockquote>
    <p> then <code>interval-lower-bounds-&gt;vector</code> returns a copy of <code><var>lower-bounds</var></code>  and <code>interval-upper-bounds-&gt;vector</code> returns a copy of <code><var>upper-bounds</var></code>. It is an error to call
      <code>interval-lower-bounds-&gt;vector</code> or <code>interval-upper-bounds-&gt;vector</code> if <code><var>interval</var></code> does not satisfy these conditions.</p>
    <p><b>Procedure: </b><code><a name="interval-volume">interval-volume</a> <var>interval</var></code></p>
    <p>If <code><var>interval</var></code> is an interval built with </p>
    <blockquote><code>(interval <var>lower-bounds</var> <var>upper-bounds</var>)</code>
    </blockquote>
    <p>then <code>interval-volume</code> returns </p>
    <blockquote><code>(apply * (map - (interval-upper-bounds-&gt;list <var>interval</var>) (interval-lower-bounds-&gt;list <var>interval</var>))</code>
    </blockquote>
    <p>It is an error to call <code>interval-volume</code> if <code><var>interval</var></code> does not satisfy this condition.</p>
    <p><b>Procedure: </b><code><a name="interval=">interval=</a> <var>interval1</var> <var>interval2</var></code></p>
    <p>If <code><var>interval1</var></code> and <code><var>interval2</var></code> are intervals built with </p>
    <blockquote><code>(interval <var>lower-bounds1</var> <var>upper-bounds1</var>)</code>
    </blockquote>
    <p>and</p>
    <blockquote><code>(interval <var>lower-bounds2</var> <var>upper-bounds2</var>)</code>
    </blockquote>
    <p>respectively, then <code>interval=</code> returns</p>
    <blockquote><code>(and (equal? <var>lower-bounds1</var> <var>lower-bounds2</var>) (equal? <var>upper-bounds1</var> <var>upper-bounds2</var>))</code>
    </blockquote>
    <p>It is an error to call <code>interval=</code> if <code><var>interval1</var></code> or <code><var>interval2</var></code> do not satisfy this condition.</p>
    <p><b>Procedure: </b><code><a name="interval-subset?">interval-subset?</a> <var>interval1</var> <var>interval2</var></code></p>
    <p>If <code><var>interval1</var></code> and <code><var>interval2</var></code> are intervals of the same dimension built with </p>
    <blockquote><code>(interval <var>lower-bounds1</var> <var>upper-bounds1</var>)</code>
    </blockquote>
    <p>and</p>
    <blockquote><code>(interval <var>lower-bounds2</var> <var>upper-bounds2</var>)</code>
    </blockquote>
    <p>respectively, then <code>interval-subset?</code> returns</p>
    <pre>
(and (equal? (map &gt;= (vector-&gt;list lower-bounds1) (vector-&gt;list lower-bounds2))
	     (map (lambda (x) #t) (vector-&gt;list lower-bounds1)))
     (equal? (map &lt;= (vector-&gt;list upper-bounds1) (vector-&gt;list upper-bounds2))
	     (map (lambda (x) #t) (vector-&gt;list lower-bounds1))))</pre>
    <p>It is an error to call <code>interval-subset?</code> if <code><var>interval1</var></code> or <code><var>interval2</var></code> do not satisfy this condition.</p>
    <p><b>Procedure: </b><code><a name="interval-contains-multi-index?">interval-contains-multi-index?</a> <var>interval</var> <var>index-0</var> <var>...</var></code></p>
    <p>If <code><var>interval</var></code> is an interval with dimension d and <code><var>index-0</var></code>, ..., form a multi-index of length d,
      then <code>interval-contains-multi-index?</code> returns <code>#t</code> if and only if</p>
    <blockquote><code>(interval-lower-bound <var>interval</var> j) &lt;= <var>index-j</var> &lt; (interval-upper-bound <var>interval</var> j)</code>
    </blockquote>
    <p>for 0&lt;= j &lt; d.</p>
    <p>It is an error to call <code>interval-contains-multi-index?</code> if <code><var>interval</var></code> and <code><var>index-0</var></code>,..., do not satisfy this condition.</p>
    <p><b>Procedure: </b><code><a name="interval-curry">interval-curry</a> <var>interval</var> <var>left-dimension</var></code></p>
    <p>Conceptually, <code>interval-curry</code> takes a d-dimensional interval [l<sub>0</sub>, u<sub>0</sub>) x [l<sub>1</sub>, u<sub>1</sub>) x ... x [l<sub>d-1</sub>, u<sub>d-1</sub>)
      and splits it into two parts</p>
    <blockquote>[l<sub>0</sub>, u<sub>0</sub>) x [l<sub>1</sub>, u<sub>1</sub>) x ... x [l<sub>left-dimension - 1</sub>, u<sub>left-dimension - 1</sub>)
    </blockquote>
    <p>and</p>
    <blockquote>[l<sub>left-dimension</sub>, u<sub>left-dimension</sub>) x  ... x [l<sub>d-1</sub>, u<sub>d-1</sub>)
    </blockquote>
    <p>This function, the inverse of Cartesian products or cross products of intervals, is used to keep track of the domains of curried arrays.</p>
    <p>More precisely, if <code><var>interval</var></code> is an interval and <code><var>left-dimension</var></code> is an exact integer that satisfies</p>
    <blockquote><code>0 &lt; <var>left-dimension</var> &lt; (interval-dimension <var>interval</var>)</code>
    </blockquote>
    <p>then <code>interval-curry</code> returns two intervals:</p>
    <pre>
(values (interval (vector (interval-lower-bound interval 0)
			  ...
			  (interval-lower-bound interval (- left-dimension 1)))
		  (vector (interval-upper-bound interval 0)
			  ...
			  (interval-upper-bound interval (- left-dimension 1))))
	(interval (vector (interval-lower-bound interval left-dimension)
			  ...
			  (interval-lower-bound interval (- (interval-dimension interval) 1)))
		  (vector (interval-upper-bound interval left-dimension)
			  ...
			  (interval-upper-bound interval (- (interval-dimension interval) 1)))))</pre>
    <p>It is an error to call <code>interval-curry</code> if its arguments do not satisfy these conditions.</p>
    <p><b>Procedure: </b><code><a name="interval-distinguish-one-axis">interval-distinguish-one-axis</a> <var>interval</var> <var>index</var></code></p>
    <p>If <code><var>interval</var></code> is an interval and
      <code>(interval-dimension <var>interval</var>)</code> is greater than one, and</p>
    <blockquote><code>0 &lt;= <var>index</var> &lt; (interval-dimension <var>interval</var>)</code>
    </blockquote>
    <p>then <code>interval-distinguish-one-axis</code> returns</p>
    <pre>
(values (interval (vector (interval-lower-bound interval 0)
			  ...         ; leaving out (interval-lower-bound interval index)
			  (interval-lower-bound interval (- left-dimension 1)))
		  (vector (interval-upper-bound interval 0)
			  ...         ; leaving out (interval-upper-bound interval index)
			  (interval-upper-bound interval (- left-dimension 1))))
	(interval (vector (interval-lower-bound interval index))
		  (vector (interval-upper-bound interval index))))</pre>
    <p>It is an error to call <code>interval-distinguish-one-axis</code> if its arguments do not satisfy these conditions.</p>
    <p><b>Procedure: </b><code><a name="interval-for-each">interval-for-each</a> <var>f</var> <var>interval</var></code></p>
    <p><b>Procedure: </b><code><a name="interval-for-each-serial">interval-for-each-serial</a> <var>f</var> <var>interval</var></code></p>
    <p>These routines assume that <code><var>interval</var></code> is an interval and <code><var>f</var></code> is a routine whose domain includes elements of <code><var>interval</var></code>.  It is an error to call
      <code>interval-for-each</code> if <code><var>interval</var></code> and <code><var>f</var></code> do not satisfy these conditions.</p>
    <p><code>interval-for-each</code> calls <code><var>f</var></code> on each element of <code><var>interval</var></code> in some unspecified order.</p>
    <p><code>interval-for-each-serial</code> calls <code><var>f</var></code> on each element of <code><var>interval</var></code> in lexicographical order.</p>
    <p><b>Procedure: </b><code><a name="interval-reduce">interval-reduce</a> <var>f</var> <var>operator</var> <var>identity</var> <var>interval</var></code></p>
    <p><b>Procedure: </b><code><a name="interval-reduce-serial">interval-reduce-serial</a> <var>f</var> <var>operator</var> <var>identity</var> <var>interval</var></code></p>
    <p>If <code><var>interval</var></code> is an interval and <code><var>f</var></code> is a routine whose domain includes elements of <code><var>interval</var></code>, then
      <code>interval-reduce-serial</code> returns</p>
    <blockquote><code>(... (<var>operator</var> (<var>operator</var> (<var>operator identity </var>(<var>f multi-index</var><sub>1</sub>)) (<var>f multi-index</var><sub>2</sub>)) (<var>f multi-index</var><sub>3</sub>)) ...)</code>
    </blockquote>
    <p>where <code><var>multi-index</var><sub>1</sub></code>, <code><var>multi-index</var><sub>2</sub></code>, ... are the multi-indices in <code><var>interval</var></code> in lexicographical order.</p>
    <p><code>interval-reduce</code> returns the same value when <code><var>operator</var></code> is associative and it doesn't matter in which order <code><var>f</var></code> is evaluated, and
      it may assume these properties.</p>
    <p>It is an error to call <code>interval-reduce</code> or <code>interval-reduce-serial</code> if <code><var>interval</var></code> and <code><var>f</var></code> do not satisfy these conditions.</p>
    <p><b>Procedure: </b><code><a name="interval-dilate">interval-dilate</a> <var>interval</var> <var>lower-diffs</var> <var>upper-diffs</var></code></p>
    <p>If <code><var>interval</var></code> is an interval with
      lower bounds l<sub>0</sub>, ..., l<sub>d-1</sub> and
      upper bounds u<sub>0</sub>, ..., u<sub>d-1</sub>, and <code><var>lower-diffs</var></code> is a vector of exact integers L<sub>0</sub>, ..., L<sub>d-1</sub> and <code><var>upper-diffs</var></code> is a vector of exact integers U<sub>0</sub>, ..., U<sub>d-1</sub>, then <code>interval-dilate</code> returns a new interval with
      lower bounds l<sub>0</sub>+L<sub>0</sub>, ..., l<sub>d-1</sub>+L<sub>d-1</sub> and
      upper bounds u<sub>0</sub>+U<sub>0</sub>, ..., u<sub>d-1</sub>+U<sub>d-1</sub>, as long as this is a
      non-empty interval.  It is an error if the arguments do not satisfy these conditions.</p>
    <p>Examples:</p>
    <blockquote>
      <pre>
(interval= (interval-dilate (interval '#(0 0) '#(100 100)) '#(1 1) '#(1 1))
	   (interval '#(1 1) '#(101 101))) =&gt; #t
(interval= (interval-dilate (interval '#(0 0) '#(100 100)) '#(-1 -1) '#(1 1))
	   (interval '#(-1 -1) '#(101 101))) =&gt; #t
(interval= (interval-dilate (interval '#(0 0) '#(100 100))  '#(0 0) '#(-50 -50))
	   (interval '#(0 0) '#(50 50))) =&gt; #t
(interval-dilate (interval '#(0 0) '#(100 100)) '#(0 0) '#(-500 -50)) =&gt; error
</pre>
    </blockquote>
    <h2>Arrays</h2>
    <h3>Procedures</h3>
    <p><b>Procedure: </b><code><a name="array">array</a> <var>domain</var> <var>getter</var></code></p>
    <p>If <code><var>domain</var></code> is an interval and <code><var>getter</var></code> is a function from
      <code><var>domain</var></code> to Scheme objects, then <code>array</code> returns an array with domain <code><var>domain</var></code>
      and getter <code><var>getter</var></code>. It is an error to call <code>array</code> if <code><var>domain</var></code> and <code><var>getter</var></code>
      do not satisfy these conditions.</p>
    <p>Example: </p>
    <pre>
(define a (array (interval '#(1 1) '#(11 11))
		 (lambda (i j)
		   (if (= i j)
		       1
		       0))))</pre>
    <p>defines an array for which <code>(array-getter a)</code> returns 1 when i=j and 0 otherwise.</p>
    <p><b>Procedure: </b><code><a name="array?">array?</a> <var>obj</var></code></p>
    <p>Returns <code>#t</code> if and only if <code><var>obj</var></code> is an array.</p>
    <p><b>Procedure: </b><code><a name="array-domain">array-domain</a> <var>array</var></code></p>
    <p><b>Procedure: </b><code><a name="array-getter">array-getter</a> <var>array</var></code></p>
    <p>If <code><var>array</var></code> is an array built by</p>
    <blockquote><code>(array <var>domain</var> <var>getter</var>)</code>
    </blockquote>
    <p>then <code>array-domain</code> returns <code><var>domain</var></code> and <code>array-getter</code> returns  <code><var>getter</var></code>.
      It is an error to call <code>array-domain</code> or <code>array-getter</code> if <code><var>array</var></code> is not an array.</p>
    <p>Example: </p>
    <pre>
(define a (array (interval '#(1 1) '#(11 11))
		 (lambda (i j)
		   (if (= i j)
		       1
		       0))))
((array-getter a) 3 3) =&gt; 1
((array-getter a) 2 3) =&gt; 0
((array-getter a) 11 0) =&gt; is an error, which may be signaled</pre>
    <p><b>Procedure: </b><code><a name="array-map">array-map</a> <var>f</var> <var>array</var> . <var>arrays</var></code></p>
    <p>If <code><var>array</var></code>, <code>(car <var>arrays</var>)</code>, ... all have the same domain and <code><var>f</var></code> is a function, then <code>array-map</code>
      returns a new array with the same domain and getter</p>
    <pre>
(lambda multi-index
  (apply f (map (lambda (g) (apply g multi-index)) (map array-getter (cons array arrays)))))</pre>
    <p>It is an error to call <code>array-map</code> if its arguments do not satisfy these conditions.</p>
    <p><b>Procedure: </b><code><a name="array-curry">array-curry</a> <var>array</var> <var>outer-dimension</var></code></p>
    <p>If <code><var>array</var></code> is an array and <code><var>outer-dimension</var></code> is an exact integer that satisfies</p>
    <blockquote><code>0 &lt; <var>outer-dimension</var> &lt; (interval-dimension (array-domain <var>array</var>))</code>
    </blockquote>
    <p>then <code>array-curry</code> returns</p>
    <pre>
(call-with-values
    (lambda () (interval-curry (array-domain array) outer-dimension))
  (lambda (outer-interval inner-interval)
    (array outer-interval
		 (lambda outer-multi-index
		   (array inner-interval
				(lambda inner-multi-index
				  (apply (array-getter array) (append outer-multi-index inner-multi-index))))))))</pre>
    <p>It is an error to call <code>array-curry</code> if its arguments do not satisfy these conditions.</p>
    <p><b>Notes:</b> This function curries <code>(array-getter <var>array</var>)</code> while keeping track of the
      domains of the outer and inner lambdas.</p>
    <p>It is expected that <code>array-curry</code> will specialize the construction of</p>
    <pre>
(lambda outer-multi-index
  (array inner-interval
	       (lambda inner-multi-index
		 (apply (array-getter array) (append outer-multi-index inner-multi-index)))))</pre>
    <p>and</p>
    <blockquote><code>(lambda inner-multi-index (apply (array-getter array) (append outer-multi-index inner-multi-index)))</code>
    </blockquote>
    <p>Example:</p>
    <pre>
(define a (array (interval '#(0 0) '#(10 10))
		       list))
((array-getter a) 3 4)  =&gt; (3 4)
(define curried-a (array-curry a 1))
((array-getter ((array-getter curried-a) 3)) 4) =&gt; (3 4)</pre>
    <p><b>Procedure: </b><code><a name="array-distinguish-one-axis">array-distinguish-one-axis</a> <var>array</var> <var>index</var></code></p>
    <p>If <code><var>array</var></code> is an array and
      <code>(interval-dimension (array-domain <var>interval</var>))</code> is greater than one, and</p>
    <blockquote><code>0 &lt;= <var>index</var> &lt; (interval-dimension (array-domain <var>interval</var>))</code>
    </blockquote>
    <p>then <code>array-distinguish-one-axis</code> returns</p>
    <pre>
(call-with-values
    (lambda () (interval-distinguish-one-axis (array-domain array) index))
  (lambda (outer-interval inner-interval)
    (array outer-interval
		 (lambda outer-multi-index
		   (array inner-interval
				(lambda (m)
				  (apply (array-getter array) (insert-arg-into-arg-list m outer-index index))))))))</pre>
    <p>where we define </p>
    <pre>
(define (insert-arg-into-arg-list arg arg-list index)
  (define (helper arg-list i)
    (if (= i 0)
	(cons arg arg-list)
	(cons arg (helper (cdr arg-list) (- i 1)))))
  (helper arg-list index))</pre>
    <p>It is an error to call <code>array-distinguish-one-axis</code> if its arguments do not satisfy these conditions.</p>
    <p><b>Notes:</b> It is expected that <code>array-distinguish-one-axis</code> will specialize the construction of </p>
    <pre>
(lambda outer-multi-index
  (array inner-interval
	       (lambda (m)
		 (apply (array-getter array) (insert-arg-into-arg-list m outer-index index)))))</pre>
    <p>and</p>
    <blockquote><code>(lambda (m) (apply (array-getter array) (insert-arg-into-arg-list m outer-index index)))</code>
    </blockquote>
    <p><b>Procedure: </b><code><a name="array-for-each">array-for-each</a> <var>f</var> <var>array</var> . <var>arrays</var></code></p>
    <p><b>Procedure: </b><code><a name="array-for-each-serial">array-for-each-serial</a> <var>f</var> <var>array</var> . <var>arrays</var></code></p>
    <p>If <code><var>array</var></code>, <code>(car <var>arrays</var>)</code>, ... all have the same domain <code><var>domain</var></code> and <code><var>f</var></code> is an appropriate function, then <code>array-for-each</code>
      calls</p>
    <pre>
(interval-for-each  (lambda multi-index
		      (apply f (map (lambda (g) (apply g multi-index)) (map array-getter (cons array arrays)))))
		    (array-domain array))</pre>
    <p>and <code>array-for-each-serial</code>
      calls</p>
    <pre>
(interval-for-each-serial  (lambda multi-index
			     (apply f (map (lambda (g) (apply g multi-index)) (map array-getter (cons array arrays)))))
			   (array-domain array))</pre>
    <p>It is expected that <code>array-map</code>, <code>array-for-each</code> and <code>array-for-each-serial</code> will specialize the construction of</p>
    <pre>
(lambda multi-index
  (apply f (map (lambda (g) (apply g multi-index)) (map array-getter (cons array arrays)))))</pre>
    <p>It is an error to call <code>array-for-each</code> if its arguments do not satisfy these conditions.</p>
    <p><b>Procedure: </b><code><a name="array-reduce">array-reduce</a> <var>operator</var> <var>identity</var> <var>array</var></code></p>
    <p><b>Procedure: </b><code><a name="array-reduce-serial">array-reduce-serial</a> <var>operator</var> <var>identity</var> <var>array</var></code></p>
    <p>If <code><var>array</var></code>  is an array then <code>array-reduce</code> returns <code>(interval-reduce (array-getter <var>array</var>) <var>operator identity</var> (array-domain <var>array</var>))</code> and <code>array-reduce-serial</code> returns <code>(interval-reduce-serial (array-getter <var>array</var>) <var>operator identity</var> (array-domain <var>array</var>))</code>.</p>
    <p><b>Procedure: </b><code><a name="array-extract">array-extract</a> <var>array</var> <var>new-domain</var></code></p>
    <p>If <code><var>array</var></code> is an array and <code><var>new-domain</var></code> is an interval that is a sub-interval of <code>(array-domain <var>array</var>)</code>, then <code>array-extract</code> returns a new array</p>
    <blockquote><code>(array <var>new-domain</var> (array-getter <var>array</var>))</code>
    </blockquote>
    <h2>Mutable Arrays</h2>
    <h3>Procedures</h3>
    <p><b>Procedure: </b><code><a name="mutable-array">mutable-array</a> <var>domain</var> <var>getter</var> <var>setter</var></code></p>
    <p>Assume that <code><var>domain</var></code> is an interval of dimension <code><var>n</var></code> and that <code><var>getter</var></code> and
      <code><var>setter</var></code> are two routines that satisfy: If </p>
    <blockquote><code>(<var>i</var><sub>1</sub>,...,<var>i</var><sub>n</sub>) != (<var>j</var><sub>1</sub>,...,<var>j</var><sub>n</sub>)</code>
    </blockquote>
    <p>are elements of <code><var>domain</var></code> and </p>
    <blockquote><code>(getter <var>j</var><sub>1</sub> ... <var>j</var><sub>n</sub>) =&gt; x</code>
    </blockquote>
    <p>then &quot;after&quot;</p>
    <blockquote><code>(setter v <var>i</var><sub>1</sub> ... <var>i</var><sub>n</sub>)</code>
    </blockquote>
    <p>we have</p>
    <blockquote><code>(getter <var>j</var><sub>1</sub> ... <var>j</var><sub>n</sub>) =&gt; x</code>
    </blockquote>
    <p>and</p>
    <blockquote><code>(getter <var>i</var><sub>1</sub>,...,<var>i</var><sub>n</sub>) =&gt; v</code>
    </blockquote>
    <p>Then <code>mutable-array</code> builds a mutable-array with domain <code><var>domain</var></code>, getter <code><var>getter</var></code> and
      setter <code><var>setter</var></code>.  A mutable-array is an array.  It is an error to call <code>mutable-array</code> if its arguments do not satisfy these conditions.</p>
    <p><b>Procedure: </b><code><a name="mutable-array?">mutable-array?</a> <var>obj</var></code></p>
    <p>Returns <code>#t</code> if and only if <code><var>obj</var></code> is a mutable-array.  Note: mutable-arrays are arrays.</p>
    <p><b>Procedure: </b><code><a name="array-setter">array-setter</a> <var>array</var></code></p>
    <p>If <code><var>array</var></code> is a mutable-array built by</p>
    <blockquote><code>(mutable-array <var>domain</var> <var>getter</var> <var>setter</var>)</code>
    </blockquote>
    <p>then <code>array-setter</code> returns <code><var>setter</var></code>. It is an error to call <code>array-setter</code>
      if <code><var>array</var></code> is not a mutable-array.</p>
    <p>Example: </p>
    <pre>
(define sparse-array
  (let ((domain (interval '#(0 0) '#(1000000 1000000)))
	(sparse-rows (make-vector 1000000 '())))
    (mutable-array domain
		   (lambda (i j)
		     (cond ((assv j (vector-ref sparse-rows i))
			    =&gt; cdr)
			   (else
			    0.0)))
		   (lambda (v i j)
		     (cond ((assv j (vector-ref sparse-rows i))
			    =&gt; (lambda (pair)
				 (set-cdr! pair v)))
			   (else
			    (vector-set! sparse-rows i (cons (cons j v) (vector-ref sparse-rows i)))))))))
((array-getter sparse-array) 12345 6789)  =&gt; 0.
((array-getter sparse-array) 0 0) =&gt; 0.
((array-setter sparse-array) 1.0 0 0) =&gt; undefined
((array-getter sparse-array) 12345 6789)  =&gt; 0.
((array-getter sparse-array) 0 0) =&gt; 1.</pre>
    <p><b>Procedure: </b><code><a name="mutable-array-curry">mutable-array-curry</a> <var>array</var> <var>outer-dimension</var></code></p>
    <p>If <code><var>array</var></code> is a mutable-array and <code><var>outer-dimension</var></code> is an exact integer that satisfies</p>
    <blockquote><code>0 &lt; <var>outer-dimension</var> &lt; (interval-dimension (array-domain <var>array</var>))</code>
    </blockquote>
    <p>then <code>mutable-array-curry</code> returns</p>
    <pre>
(call-with-values
    (lambda () (interval-curry (array-domain array) outer-dimension))
  (lambda (outer-interval inner-interval)
    (array outer-interval
	   (lambda outer-multi-index
	     (mutable-array inner-interval
			    (lambda inner-multi-index
			      (apply (array-getter array) (append outer-multi-index inner-multi-index)))
			    (lambda (v . inner-multi-index)
			      (apply (array-setter array) v (append outer-multi-index inner-multi-index))))))))</pre>
    <p>It is an error to call <code>mutable-array-curry</code> if its arguments do not satisfy these conditions.</p>
    <p><b>Notes:</b> This function curries <code>(array-getter <var>array</var>)</code>
      and <code>(array-setter <var>array</var>)</code> while keeping track of the
      domains of the outer and inner lambdas.</p>
    <p>It is expected that <code>mutable-array-curry</code> will specialize the construction of</p>
    <pre>
(lambda outer-multi-index
  (mutable-array inner-interval
		       (lambda inner-multi-index
			 (apply (array-getter array) (append outer-multi-index inner-multi-index)))
		       (lambda (v . inner-multi-index)
			 (apply (array-setter array) v (append outer-multi-index inner-multi-index)))))</pre>
    <p>and</p>
    <blockquote><code>(lambda inner-multi-index (apply (array-getter array) (append outer-multi-index inner-multi-index)))</code>
    </blockquote>
    <p>and</p>
    <blockquote><code>(lambda (v . inner-multi-index) (apply (array-setter array) v (append outer-multi-index inner-multi-index)))</code>
    </blockquote>
    <p><b>Procedure: </b><code><a name="mutable-array-distinguish-one-axis">mutable-array-distinguish-one-axis</a> <var>array</var> <var>index</var></code></p>
    <p>If <code><var>array</var></code> is a mutable-array and
      <code>(interval-dimension (array-domain <var>interval</var>))</code> is greater than one, and</p>
    <blockquote><code>0 &lt;= <var>index</var> &lt; (interval-dimension (array-domain <var>interval</var>))</code>
    </blockquote>
    <p>then <code>mutable-array-distinguish-one-axis</code> returns</p>
    <pre>
(call-with-values
    (lambda () (interval-distinguish-one-axis (array-domain array) index))
  (lambda (outer-interval inner-interval)
    (array outer-interval
		 (lambda outer-multi-index
		   (mutable-array inner-interval
					(lambda (m)
					  (apply (array-getter array) (insert-arg-into-arg-list m outer-index index)))
					(lambda (v m)
					  (apply (array-setter array) v (insert-arg-into-arg-list m outer-index index))))))))</pre>
    <p>where we define </p>
    <pre>
(define (insert-arg-into-arg-list arg arg-list index)
  (define (helper arg-list i)
    (if (= i 0)
	(cons arg arg-list)
	(cons arg (helper (cdr arg-list) (- i 1)))))
  (helper arg-list index))</pre>
    <p>It is an error to call <code>mutable-array-distinguish-one-axis</code> if its arguments do not satisfy these conditions.</p>
    <p><b>Notes:</b> It is expected that <code>mutable-array-distinguish-one-axis</code> will specialize the construction of </p>
    <pre>
(lambda outer-multi-index
  (mutable-array inner-interval
		       (lambda (m)
			 (apply (array-getter array) (insert-arg-into-arg-list m outer-index index)))
		       (lambda (v m)
			 (apply (array-setter array) v (insert-arg-into-arg-list m outer-index index)))))</pre>
    <p>and</p>
    <blockquote><code>(lambda (m) (apply (array-getter array) (insert-arg-into-arg-list m outer-index index)))</code>
    </blockquote>
    <p>and</p>
    <blockquote><code>(lambda (v m) (apply (array-setter array) v (insert-arg-into-arg-list m outer-index index)))</code>
    </blockquote>
    <h2>Storage classes</h2>
    <p>Conceptually, a storage-class is a set of functions to manage the backing store of a specialized-array.
      The functions allow one to make a backing store, to get values from the store and to set new values, to return the length of the store, and to specify a default value for initial elements of the backing store.  Typically, a backing store is a (heterogeneous or homogenous) vector.</p>
    <h3>Procedures</h3>
    <p><b>Procedure: </b><code><a name="make-storage-class">make-storage-class</a> <var>getter</var> <var>setter</var> <var>checker</var> <var>maker</var> <var>length</var> <var>default</var></code></p>
    <p>Here we assume the following relationships between the arguments of <code>make-storage-class</code>.  Assume that the &quot;elements&quot; of
      the backing store are of some &quot;type&quot;, either heterogeneous (all Scheme types) or homogeneous (of some restricted type).</p>
    <ul>
      <li><code>(<var>maker n</var> <var>value</var>)</code> returns an object containing <code><var>n</var></code> elements of value <code><var>value</var></code>.</li>
      <li>If <code><var>v</var></code> is an object created by <code>(<var>maker n value</var>)</code> and  0 &lt;= <code><var>i</var></code> &lt; <code><var>n</var></code>, then <code>(<var>getter v i</var>)</code> returns the current value of the <code><var>i</var></code>'th element of <code><var>v</var></code>, and <code>(<var>checker</var> (<var>getter v i</var>)) =&gt; #t</code>.</li>
      <li>If <code><var>v</var></code> is an object created by <code>(<var>maker n value</var>)</code>,  0 &lt;= <code><var>i</var></code> &lt; <code><var>n</var></code>, and <code>(<var>checker</var> <var>val</var>) =&gt; #t</code>, then <code>(<var>setter v i val</var>)</code> sets the value of the <code><var>i</var></code>'th element of  <code><var>v</var></code> to <code><var>val</var></code>.</li>
      <li>If <code><var>v</var></code> is an object created by <code>(<var>maker n value</var>)</code> then <code>(<var>length v</var>)</code> returns <code><var>n</var></code>.</li></ul>
    <p>If the arguments do not satisfy these conditions, then it is an error to call <code>make-storage-class</code></p>
    <p>Note that we assume that <code><var>getter</var></code> and <code><var>setter</var></code> generally take <i>O</i>(1) time to execute.</p>
    <p><b>Procedure: </b><code><a name="storage-class-getter">storage-class-getter</a> <var>m</var></code></p>
    <p><b>Procedure: </b><code><a name="storage-class-setter">storage-class-setter</a> <var>m</var></code></p>
    <p><b>Procedure: </b><code><a name="storage-class-checker">storage-class-checker</a> <var>m</var></code></p>
    <p><b>Procedure: </b><code><a name="storage-class-maker">storage-class-maker</a> <var>m</var></code></p>
    <p><b>Procedure: </b><code><a name="storage-class-length">storage-class-length</a> <var>m</var></code></p>
    <p><b>Procedure: </b><code><a name="storage-class-default">storage-class-default</a> <var>m</var></code></p>
    <p>If <code><var>m</var></code> is an object created by</p>
    <blockquote><code>(make-storage-class <var>setter getter checker maker length default</var>)</code>
    </blockquote>
    <p> then <code>storage-class-getter</code> returns <code><var>getter</var></code>, <code>storage-class-setter</code> returns <code><var>setter</var></code>, <code>storage-class-checker</code> returns <code><var>checker</var></code>, <code>storage-class-maker</code> returns <code><var>maker</var></code>, and <code>storage-class-default</code> returns <code><var>default</var></code>.  Otherwise, it is an error to call any of these routines.</p>
    <h3>Global Variables</h3>
    <p><b>Variable: </b><code><a name="generic-storage-class">generic-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="s8-storage-class">s8-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="s16-storage-class">s16-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="s32-storage-class">s32-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="s64-storage-class">s64-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="u1-storage-class">u1-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="u8-storage-class">u8-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="u16-storage-class">u16-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="u32-storage-class">u32-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="u64-storage-class">u64-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="f32-storage-class">f32-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="f64-storage-class">f64-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="c64-storage-class">c64-storage-class</a></code></p>
    <p><b>Variable: </b><code><a name="c128-storage-class">c128-storage-class</a></code></p>
    <p><code>generic-storage-class</code> is defined by</p>
    <blockquote><code>(define generic-storage-class (make-storage-class vector-ref vector-set! (lambda (arg) #t) make-vector vector-length #f))</code>
    </blockquote>Furthermore, <code>s<var>X</var>-storage-class</code> is defined for <code><var>X</var></code>=8, 16, 32, and 64 (which have default values 0 and
    manipulate exact integer values between -2<sup><var>X</var>-1</sup> and
    2<sup><var>X</var>-1</sup>-1 inclusive),
     <code>u<var>X</var>-storage-class</code> is defined for <code><var>X</var></code>=1, 8, 16, 32, and 64 (which have default values 0 and manipulate exact integer values between 0 and
    2<sup><var>X</var></sup>-1 inclusive),
    <code>f<var>X</var>-storage-class</code> is defined for <code><var>X</var></code>= 32 and 64 (which have default value 0.0 and manipulate 32- and 64-bit floating-point numbers), and
    <code>c<var>X</var>-storage-class</code> is defined for <code><var>X</var></code>= 64 and 128 (which have default value 0.0+0.0i and manipulate complex numbers with, respectively,32- and 64-bit floating-point numbers as real and imaginary parts).  Each of these
    could be defined simply as generic-storage-class, but it is assumed that implementations with homogeneous arrays will give definitions
    that either save space, avoid boxing, etc., for the specialized arrays.
    <h2>Indexers</h2>
    <h3>Procedures</h3>
    <p><b>Procedure: </b><code><a name="indexer=">indexer=</a> <var>indexer1</var> <var>indexer2</var> <var>interval</var></code></p>
    <p>If <code><var>indexer1</var></code> and <code><var>indexer2</var></code> are one-to-one affine mappings from <code><var>interval</var></code>
      to the interval <code>[0,<var>K</var>)</code> for some <code><var>K</var></code>, then <code>indexer=</code> returns <code>#t</code>
      if <code><var>indexer1</var></code> and <code><var>indexer2</var></code> take the same values on all elements of <code><var>interval</var></code>;
      otherwise <code>indexer=</code> returns <code>#f</code>.  It is an error to call <code>indexer=</code> if its
      arguments don't satisfy these conditions.</p>
    <h2>Specialized Arrays</h2>
    <h3>Global Variable</h3>
    <p><b>Variable: </b><code><a name="specialized-array-default-safe?">specialized-array-default-safe?</a></code></p>
    <p>Determines whether the setters and getters of specialized-arrays check their arguments for correctness by default.  Initially it has the value <code>#f</code>.</p>
    <h3>Procedures</h3>
    <p><b>Procedure: </b><code><a name="specialized-array">specialized-array</a> domain: <var>domain</var> storage-class: <var>storage-class</var> [ body: <var>body</var> ] [ indexer: <var>indexer</var> ] [ initializer-value: <var>initializer-value</var> ] [ safe?: <var>safe?</var> ]</code></p>
    <p>Builds a specialized-array.  <code><var>domain</var></code> must be an interval; <code><var>storage-class</var></code> must
       be a storage-class;  if <code><var>body</var></code> is given, it must be of the same type as that returned by
      <code>(storage-class-maker <var>storage-class</var>)</code>; if <code><var>initializer-value</var></code> is given, it must be storable
      in <code><var>body</var></code>; at most one of <code><var>initializer-value</var></code> and <code><var>body</var></code> can be given; if <code><var>indexer</var></code> is given, it must be a one-to-one affine mapping from <code><var>domain</var></code> to
      [0,<code>((storage-class-length <var>storage-class</var>) <var>body</var>)</code>); the variable <code><var>safe?</var></code> determines whether the multi-index arguments to the getter and setter are checked to be in the domain, and whether the value of the setter is storable in the body;
      the getter and setter of the result are defined by</p>
    <pre>
(lambda (i_0 ... i_n-1)
  ((storage-class-getter storage-class)
   body
   (indexer i_0 ... i_n-1)))</pre>
    <p>and</p>
    <pre>
(lambda (v i_0 ... i_n-1)
  ((storage-class-setter storage-class)
   body
   (indexer i_0 ... i_n-1)
   v))</pre>
    <p>The default values for arguments that are omitted are as follows:</p>
    <p>Initializer-value: <code>(storage-class-default storage-class)</code></p>
    <p>Body:</p>
    <pre>
((storage-class-maker storage-class)
 (interval-volume domain)
 initializer-value)</pre>
    <p>Indexer: The one-to-one mapping of elements of <code><var>domain</var></code> to [0,<code>(interval-volume <var>domain</var>)</code>) in
      lexicographical order.</p>
    <p>Safe?: The current value of the global variable <code>specialized-array-default-safe?</code>.</p>
    <p><b>Procedure: </b><code><a name="specialized-array?">specialized-array?</a> <var>obj</var></code></p>
    <p>Returns <code>#t</code> if <code><var>obj</var></code> is a specialized-array, and <code>#f</code> otherwise. A specialized-array is a mutable-array, and hence an array.</p>
    <p><b>Procedure: </b><code><a name="array-body">array-body</a> <var>array</var></code></p>
    <p><b>Procedure: </b><code><a name="array-indexer">array-indexer</a> <var>array</var></code></p>
    <p><b>Procedure: </b><code><a name="array-storage-class">array-storage-class</a> <var>array</var></code></p>
    <p><b>Procedure: </b><code><a name="array-safe?">array-safe?</a> <var>array</var></code></p>
    <p><code>array-body</code> returns the body of <code><var>array</var></code>, <code>array-indexer</code> returns the indexer of <code><var>array</var></code>, <code>array-storage-class</code> returns the storage-class of <code><var>array</var></code>, and <code>array-safe?</code> is true if and only if the arguments of <code>(array-getter <var>array</var>)</code> and <code>(array-setter <var>array</var>)</code> are checked for correctness. It is an error to call any of these routines if <code><var>array</var></code> is not a specialized-array.</p>
    <p><b>Procedure: </b><code><a name="specialized-array-share!">specialized-array-share!</a> <var>array</var> <var>new-domain</var> <var>new-domain-&gt;old-domain</var></code></p>
    <p>Constructs a new specialized-array that shares the body of the specialized-array <code><var>array</var></code>.
      Returns an object that is behaviorally equivalent to</p>
    <pre>
(specialized-array domain:        new-domain
	     storage-class: (array-storage-class array)
	     body:          (array-body array)
	     indexer:       (lambda multi-index
			      (call-with-values
				  (lambda ()
				    (apply new-domain-&gt;old-domain multi-index))
			        (specialized-array-indexer array))))</pre>
    <p><code><var>new-domain-&gt;old-domain</var></code> must be an affine one-to-one mapping from <code>(array-domain <var>array</var>)</code> to
      <code><var>new-domain</var></code>.</p>
    <p>Note: It is assumed that affine structure of the composition of <code><var>new-domain-&gt;old-domain</var></code> and <code>(specialized-array-indexer <var>array</var></code> will be used to simplify:</p>
    <pre>
(lambda multi-index
  (call-with-values
      (lambda ()
	(apply new-domain-&gt;old-domain multi-index))
    (specialized-array-indexer array)))</pre>
    <p><b>Procedure: </b><code><a name="specialized-array-curry">specialized-array-curry</a> <var>array</var> <var>outer-dimension</var></code></p>
    <p>It is an error to call <code>specialized-array-curry</code> unless
       <code><var>array</var></code> is a specialized-array
      and <code><var>outer-dimension</var></code> is an exact integer that satisfies</p>
    <blockquote><code>0 &lt; <var>outer-dimension</var> &lt; (interval-dimension (specialized-array-domain <var>array</var>)).</code>
    </blockquote>
    <p><code>specialized-array-curry</code> returns</p>
    <pre>
(call-with-values
    (lambda () (interval-curry (specialized-array-domain array) outer-dimension))
  (lambda (outer-interval inner-interval)
    (array outer-interval
	   (lambda outer-multi-index
	     (specialized-array-share! array
				 outer-interval
				 (lambda inner-multi-index
				   (apply values (append outer-multi-index inner-multi-index))))))))</pre>
    <p><b>Notes:</b> This function curries <code>(array-getter <var>array</var>)</code>
      and <code>(array-setter <var>array</var>)</code> while keeping track of the
      domains of the outer and inner lambdas.</p>
    <p>It is expected that <code>specialized-array-curry</code> will specialize the construction of</p>
    <blockquote><code>(lambda outer-multi-index
      		   (specialized-array-share! array
      				       outer-interval
      				       (lambda inner-multi-index
      					 (apply values (append outer-multi-index inner-multi-index)))))</code>
    </blockquote>
    <p><b>Procedure: </b><code><a name="specialized-array-distinguish-one-axis">specialized-array-distinguish-one-axis</a> <var>array</var> <var>index</var></code></p>
    <p>It is an error to call <code>specialized-array-distinguish-one-axis</code> unless
       <code><var>array</var></code> is a specialized-array and
      <code>(interval-dimension (specialized-array-domain <var>interval</var>))</code> is greater than one, and</p>
    <blockquote><code>0 &lt;= <var>index</var> &lt; (interval-dimension (specialized-array-domain <var>array</var>))</code>
    </blockquote>
    <p><code>specialized-array-distinguish-one-axis</code> returns</p>
    <pre>
(call-with-values
    (lambda () (interval-distinguish-one-axis (specialized-array-domain array) index))
  (lambda (outer-interval inner-interval)
    (array outer-interval
		 (lambda outer-multi-index
		   (specialized-array-share! array
				       inner-interval
				       (lambda (m) (apply values (insert-arg-into-arg-list m outer-index index))))))))</pre>
    <p>where we define </p>
    <pre>
(define (insert-arg-into-arg-list arg arg-list index)
  (define (helper arg-list i)
    (if (= i 0)
	(cons arg arg-list)
	(cons arg (helper (cdr arg-list) (- i 1)))))
  (helper arg-list index))</pre>
    <p>It is expected that <code>specialized-array-distinguish-one-axis</code> will specialize the construction of </p>
    <pre>
(lambda outer-multi-index
  (specialized-array-share! array
		      inner-interval
		      (lambda (m) (apply values (insert-arg-into-arg-list m outer-index index)))))</pre>
    <p><b>Procedure: </b><code><a name="array-&gt;specialized-array">array-&gt;specialized-array</a> <var>array</var> [ <var>result-storage-class</var> generic-storage-class ] [ <var>safe?</var> #f ]</code></p>
    <p><b>Procedure: </b><code><a name="array-&gt;specialized-array-serial">array-&gt;specialized-array-serial</a> <var>array</var> [ <var>result-storage-class</var> generic-storage-class [ <var>safe?</var> #f ]</code></p>
    <p>If <code><var>array</var></code> is an array whose elements can be manipulated by the storage-class
      <code><var>result-storage-class</var></code>, then the specialized-array returned by <code>array-&gt;specialized-array</code> can be defined by:</p>
    <pre>
(let ((result (specialized-array domain:        (array-domain array)
			   storage-class: result-storage-class
			   safe?:         safe?)))
  (interval-for-each (lambda multi-index
		       (apply (array-setter result) (apply (array-getter array) multi-index) multi-index))
		     (array-domain array))
  result)</pre>
    <p>Otherwise it is an error to call <code>array-&gt;specialized-array</code>.</p>
    <p><code>array-&gt;specialized-array</code>  does not specify
      the order in which <code>(array-getter <var>array</var>)</code> is applied to the multi-indices in <code>(array-domain <var>array</var>)</code>.</p>
    <p>Similarly, the specialized-array returned by <code>array-&gt;specialized-array-serial</code> can be defined by:</p>
    <pre>
(let ((result (specialized-array domain:        (array-domain array)
			   storage-class: result-storage-class
			   safe?:         safe?)))
  (interval-for-each-serial (lambda multi-index
			      (apply (array-setter result) (apply (array-getter array) multi-index) multi-index))
			    (array-domain array))
  result)</pre>
    <p>Thus, <code>array-&gt;specialized-array-serial</code> evaluates <code>(array-getter <var>array</var>)</code> to the multi-indices in
      <code>(array-domain <var>array</var>)</code> in lexicographical order.</p>
    <h1>Implementation</h1>
    <p>We provide an implementation in Gambit-C; the nonstandard techniques used
      in the implementation are: DSSSL-style optional and keyword arguments; a
      unique object to indicate absent arguments; <code>define-structure</code>;
      and <code>define-macro</code>.</p>
    <h1>Relationship to other SRFIs</h1>
    <p>Final SRFIs <a href="#SRFI-25">25</a>, <a href="#SRFI-47">47</a>, <a href="#SRFI-58">58</a>, and <a href="#SRFI-63">63</a> deal with &quot;Multi-dimensional Array Primitives&quot;, &quot;Array&quot;, &quot;Array Notation&quot;,
      and &quot;Homogeneous and Heterogeneous Arrays&quot;, respectively.  Each of these previous SRFIs deal with what we call in this SRFI
      specialized-arrays.  Many of the functions in these previous SRFIs  have corresponding forms in this SRFI.  For example, from SRFI 63, we can
      translate: </p>
    <dl>
      <dt><code>(array? obj)</code></dt>
      <dd><code>(array? obj)</code></dd>
      <dt><code>(Array-rank a)</code></dt>
      <dd><code>(interval-dimension (array-domain obj))</code></dd>
      <dt><code>(make-array prototype k1 ...)</code></dt>
      <dd><code>(specialized-array domain: (interval (vector 0 ...) (vector k1 ...)) storage-class: storage-class)</code>.</dd>
      <dt><code>(make-shared-array array mapper k1 ...)</code></dt>
      <dd><code>(specialized-array-share! array (interval (vector 0 ...) (vector k1 ...)) mapper)</code></dd>
      <dt><code>(array-in-bounds? array index1 ...)</code></dt>
      <dd><code>(interval-contains-multi-index? (array-domain array) index1 ...)</code></dd>
      <dt><code>(array-ref array k1 ...)</code></dt>
      <dd><code>((array-getter array) k1 ...)</code></dd>
      <dt><code>(array-set! array obj k1 ...)</code></dt>
      <dd><code>((array-setter array) obj k1 ...)</code></dd></dl>
    <p>At the same time, this SRFI has some special features:</p>
    <ul>
      <li>Intervals, used as the domains of arrays in this SRFI, are useful
        objects in their own rights, with their own procedures.  We make a sharp distinction between the domains
        of arrays and the arrays themselves.</li>
      <li>Intervals can have nonzero lower bounds in each dimension.</li>
      <li>Intervals cannot be empty.</li>
      <li>Arrays must have a getter, but may have no setter.  For example, on a system with eight-bit chars, one
        can write a function to read greyscale images in the PGM format of the netpbm package as follows.  The  lexicographical
        order in array-&gt;specialized-array-serial guarantees the the correct order of execution of the input procedures:
        <pre>
(define make-pgm   cons)
(define pgm-greys  car)
(define pgm-pixels cdr)

(define (read-pgm file)

  (define (read-pgm-object port)
    (skip-white-space port)
    (let ((o (read port)))
      (read-char port) ; to skip the newline or next whitespace
      (if (eof-object? o)
	  (error &quot;reached end of pgm file&quot;)
	  o)))

  (define (skip-to-end-of-line port)
    (let loop ((ch (read-char port)))
      (if (not (eq? ch #\newline))
	  (loop (read-char port)))))

  (define (white-space? ch)
    (case ch 
      ((#\newline #\space #\tab) #t)
      (else #f)))

  (define (skip-white-space port)
    (let ((ch (peek-char port)))
      (cond ((white-space? ch) (read-char port) (skip-white-space port))
	    ((eq? ch #\#) (skip-to-end-of-line port)(skip-white-space port))
	    (else #f))))

  (call-with-input-file
      file
    (lambda (port)
      (let* ((header (read-pgm-object port))
	     (columns (read-pgm-object port))
	     (rows (read-pgm-object port))
	     (greys (read-pgm-object port)))
	(make-pgm greys
		  (array-&gt;specialized-array-serial
		   (array
		    (interval '#(0 0)
			      (vector rows columns))
		    (cond ((or (eq? header 'p5)                                     ;; pgm binary
			       (eq? header 'P5))
			   (if (&lt; greys 256)
			       (lambda (i j)                                        ;; one byte/pixel
				 (char-&gt;integer (read-char port)))
			       (lambda (i j)                                        ;; two bytes/pixel, little-endian
				 (let* ((first-byte (char-&gt;integer (read-char port)))
					(second-byte (char-&gt;integer (read-char port))))
				   (+ (* second-byte 256) first-byte)))))
			  ((or (eq? header 'p2)                                     ;; pgm ascii
			       (eq? header 'P2))
			   (lambda (i j)
			     (read port)))
			  (else
			   (error &quot;read-pgm: not a pgm file&quot;))))))))))</pre></li></ul>
    <h1>References</h1>
    <ol>
      <li><a name="bawden" href="http://groups-beta.google.com/group/comp.lang.scheme/msg/6c2f85dbb15d986b?hl=en&amp;">&quot;multi-dimensional arrays in R5RS?&quot;</a>, by Alan Bawden.</li>
      <li><a name="SRFI-4" href="http://srfi.schemers.org/srfi-4/">SRFI 4:  Homogeneous Numeric Vector Datatypes</a>, by Marc Feeley.</li>
      <li><a name="SRFI-25" href="http://srfi.schemers.org/srfi-25/">SRFI 25: Multi-dimensional Array Primitives</a>, by Jussi Piitulainen.</li>
      <li><a name="SRFI-47" href="http://srfi.schemers.org/srfi-47/">SRFI 47: Array</a>, by Aubrey Jaffer.</li>
      <li><a name="SRFI-58" href="http://srfi.schemers.org/srfi-58/">SRFI 58: Array Notation</a>, by Aubrey Jaffer.</li>
      <li><a name="SRFI-63" href="http://srfi.schemers.org/srfi-63/">SRFI 63: Homogeneous and Heterogeneous Arrays</a>, by Aubrey Jaffer.</li></ol>
  </body>
</html>